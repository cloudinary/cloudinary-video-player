import { ConsoleMessage, Page, expect } from '@playwright/test';
import { vpTest } from '../fixtures/vpTest';
import { LINKS } from '../testData/pageLinksData';

/**
 * Console error test generated by LINKS object array data.
 */
for (const link of LINKS) {
    vpTest(`Test console errors on link ${link.name}`, async ({ page, consoleErrors, vpExamples }) => {
        await vpExamples.clickLinkByName(link.name);
        await waitForPageToLoadWithTimeout(page, 5000);
        expect(page.url()).toContain(link.endpoint);
        handleCommonBrowsersErrors(link.name, consoleErrors);
    });
}

/**
 * Testing number of links in page.
 */
vpTest('Link count test', async ({ page }) => {
    const expectedNumberOfLinks = 37;
    const numberOfLinks = await page.getByRole('link').count();
    expect(numberOfLinks).toBe(expectedNumberOfLinks);
});

/**
 * Helper function to handle common browser errors.
 */
function handleCommonBrowsersErrors(linkName: string, consoleErrors: ConsoleMessage[]) {
    switch (linkName) {
        case 'Custom Errors':
            validatePageErrors(
                consoleErrors,
                ['(CODE:999 undefined) My custom error message'],
                ['No compatible source was found for this media', 'Video cannot be played Public ID snow_horses not found', 'the server responded with a status of 404', 'Cannot read properties of undefined']
            );
            break;
        case 'Debug mode':
            validatePageErrors(consoleErrors, ['invalid player configuration', `cloudinary video player: \'fluid\' should be a boolean`], []);
            break;
        case 'VAST & VPAID Support':
            validatePageErrors(consoleErrors, ['The Cross-Origin-Opener-Policy header'], ["Blocked script execution in 'about:blank' because the document's frame is sandboxed and the 'allow-scripts' permission is not set"]);
            break;
        default:
            expect(consoleErrors).toHaveLength(0);
    }
}

/**
 * Wait until there are no network connections for at least 5000 ms or for given timeout to pass.
 * Needed for console logs to appear. and in pages that loading video 'waitForLoadState('networkidle')' entering a long loop.
 */
async function waitForPageToLoadWithTimeout(page: Page, timeout: number): Promise<unknown> {
    // return Promise.race([page.waitForLoadState('networkidle'), new Promise((r) => setTimeout(r, timeout))]);
    return new Promise((r) => setTimeout(r, timeout));
}

/**
 * Validating that the expected error is part of the console errors
 */
function validatePageErrors(consoleErrors: ConsoleMessage[], expectedErrorMessages: string[], ignoreErrorMessages: string[]): void {
    /**
     * Filters console messages to exclude ignored messages
     */
    const relevantMessages = consoleErrors.filter((consoleError) => !ignoreErrorMessages.some((ignoreError) => consoleError.text().includes(ignoreError)));

    /**
     * Filters expected error messages that are not found in relevant console messages
     */
    const missingExpectedErrors = expectedErrorMessages.filter((expectedErrorMessage) => !relevantMessages.some((relevantError) => relevantError.text().includes(expectedErrorMessage)));

    expect(missingExpectedErrors.length, `The following expected console errors were not found: ${JSON.stringify(missingExpectedErrors)}`).toBe(0);

    /**
     * Filters relevant console messages that are not part of the expected error messages
     */
    const unexpectedErrors = relevantMessages.filter((relevantError) => !expectedErrorMessages.some((expectedErrorMessage) => relevantError.text().includes(expectedErrorMessage)));

    expect(unexpectedErrors.length, `The following unexpected console errors were found: ${JSON.stringify(unexpectedErrors)}`).toBe(0);
}
